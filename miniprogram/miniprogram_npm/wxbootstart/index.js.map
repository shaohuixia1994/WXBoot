{"version":3,"sources":["index.js","lib/wxboot.js","lib/wx-updata.js","lib/obaa.js","lib/path.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,ACHA,AHSA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AELA,AFMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const WXBoot = require('./lib/wxboot');\r\nmodule.exports = {\r\n    WXBoot:WXBoot\r\n}","var __TEMP__ = require('./wx-updata');var Empty = __TEMP__['Empty'];\nvar __TEMP__ = require('./wx-updata');var objToPath = __TEMP__['objToPath'];\nvar __TEMP__ = require('./obaa');var obaa = __REQUIRE_DEFAULT__(__TEMP__);\nvar __TEMP__ = require('./path');var getPath = __TEMP__['getPath'];var needUpdate = __TEMP__['needUpdate'];var fixPath = __TEMP__['fixPath'];var getUsing = __TEMP__['getUsing'];\n/*!\n * 1.自动整合 wx-updata.js 页面方法 增加$upData,Empty\n * 2.修改路由支持多$page替换\n * 3.页面绑定APP.js全局变量\n * $getStore $bindStore $setBind+绑定数据字段名\n * 4.加载绑定方法，绑定方法库\n * todo-统一数据中心 ,全局方法栈，后台方法栈\n *  v1.0.0\n * https://github.com/shaohuixia1994/WXBoot/\n * License MIT\n */\nmodule.exports =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\nvar undef = void(0)\nfunction hasOwn (obj, prop) {\n\treturn obj && obj.hasOwnProperty && obj.hasOwnProperty(prop)\n}\nfunction _nextTick() {\n\t// global\n\tvar ctx = this\n\treturn function () {\n\t\treturn setTimeout.apply(ctx, arguments)\n\t}\n}\nvar fns = {\n\ttype: function(obj) {\n\t\tif (obj === null) return 'null'\n\t\telse if (obj === undef) return 'undefined'\n\t\tvar m = /\\[object (\\w+)\\]/.exec(Object.prototype.toString.call(obj))\n\t\treturn m ? m[1].toLowerCase() : ''\n\t},\n\textend: function(obj) {\n\t\tif (fns.type(obj) != 'object' && fns.type(obj) != 'function') return obj;\n\t\tvar source, prop;\n\t\tfor (var i = 1, length = arguments.length; i < length; i++) {\n\t\t\tsource = arguments[i];\n\t\t\tfor (prop in source) {\n\t\t\t\tif (hasOwn(source, prop)) {\n\t\t\t\t\tobj[prop] = source[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn obj;\n\t},\n\tobjEach: function (obj, fn) {\n\t\tif (!obj) return\n\t\tfor(var key in obj) {\n\t\t\tif (hasOwn(obj, key)) {\n\t\t\t\tif(fn(key, obj[key]) === false) break\n\t\t\t}\n\t\t}\n\t},\n\tnextTick: _nextTick(),\n\t/**\n\t * Lock function before lock release\n\t */\n\tlock: function lock(fn) {\n\t\tvar pending\n\t\treturn function () {\n\t\t\tif (pending) return\n\t\t\tpending = true\n\t\t\tvar args = [].slice.call(arguments, 0)\n\t\t\targs.unshift(function () {\n\t\t\t\tpending = false\n\t\t\t})\n\t\t\treturn fn.apply(this, args)\n\t\t}\n\t},\n\t/**\n\t * Queue when pending, execute one by one\n\t * @param {Function} fn executed function\n\t * @param {Number} capacity Allow run how much parall task at once\n\t * @async\n\t */\n\tqueue: function queue(fn, capacity) {\n\t\tcapacity = capacity || 1\n\t\tvar callbacks = []\n\t\tvar remains = capacity\n\t\tfunction next() {\n\t\t\tvar item = callbacks.shift()\n\t\t\tif (!item) {\n\t\t\t\tremains = capacity\n\t\t\t\treturn\n\t\t\t}\n\t\t\tremains--\n\t\t\tvar fn = item[0]\n\t\t\tvar ctx = item[1]\n\t\t\tvar args = item[2]\n\t\t\targs.unshift(function () {\n\t\t\t\t// once task is done, remains increasing\n\t\t\t\tremains ++\n\t\t\t\t// then check or call next task\n\t\t\t\tnext.apply(this, arguments)\n\t\t\t})\n\t\t\tfns.nextTick(function () {\n\t\t\t\treturn fn.apply(ctx, args)\n\t\t\t})\n\t\t}\n\t\treturn function () {\n\t\t\tcallbacks.push([fn, this, [].slice.call(arguments, 0)])\n\t\t\tif (!remains) return\n\t\t\treturn next()\n\t\t}\n\t},\n\t/**\n\t * Queue and wait for the same result\n\t * @param {Function} delegate method\n\t * @return {Function} the method receive a callback function\n\t */\n\tdelegator: function (fn) {\n\t\tvar pending\n\t\tvar queue = []\n\t\treturn function (cb) {\n\t\t\tif (pending) return queue.push(cb)\n\t\t\tpending = true\n\t\t\tfn.call(this, function () {\n\t\t\t\tpending = false\n\t\t\t\tvar ctx = this\n\t\t\t\tvar args = arguments\n\t\t\t\tcb && cb.apply(ctx, args)\n\t\t\t\tqueue.forEach(function (f) {\n\t\t\t\t\tf && f.apply(ctx, args)\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t},\n\t/**\n\t * Call only once\n\t */\n\tonce: function (fn/*[, ctx]*/) {\n\t\tvar args = arguments\n\t\tvar called\n\t\treturn function () {\n\t\t\tif (called || !fn) return\n\t\t\tcalled = true\n\t\t\treturn fn.apply(args.length >=2 ? args[1] : null, arguments)\n\t\t}\n\t},\n\t/**\n\t *  解析 query 字符串\n\t **/\n\tqueryParse: function(search, spliter) {\n\t\tif (!search) return {};\n\n\t\tspliter = spliter || '&';\n\n\t\tvar query = search.replace(/^\\?/, ''),\n\t\t\tqueries = {},\n\t\t\tsplits = query ? query.split(spliter) : null;\n\n\t\tif (splits && splits.length > 0) {\n\t\t\tsplits.forEach(function(item) {\n\t\t\t\titem = item.split('=');\n\t\t\t\tvar key = item.splice(0, 1),\n\t\t\t\t\tvalue = item.join('=');\n\t\t\t\tqueries[key] = value;\n\t\t\t});\n\t\t}\n\t\treturn queries;\n\t},\n\t/**\n\t * URL添加query\n\t */\n\tqueryJoin: function (api, queries, unencoded) {\n\t\tvar qs = fns.queryStringify(queries, '&', unencoded)\n\t\tif (!qs) return api\n\n\t\tvar sep\n\t\tif (/[\\?&]$/.test(api)) {\n\t\t\tsep = ''\n\t\t} else if (~api.indexOf('?')) {\n\t\t\tsep = '&'\n\t\t} else {\n\t\t\tsep = '?'\n\t\t}\n\t\treturn api + sep + qs\n\t},\n\t/**\n\t * query 对象转换字符串\n\t */\n\tqueryStringify: function (params, spliter, unencoded) {\n\t\tif (!params) return ''\n\t\treturn Object.keys(params).map(function (k) {\n\t\t\tvar v = params[k]\n\t\t\treturn k + '=' + (unencoded ? v : encodeURIComponent(v))\n\t\t}).join(spliter || '&')\n\t},\n\twrapFun: function (pre, wrapper) {\n\t\treturn function () {\n\t\t\ttry {\n\t\t\t\twrapper && wrapper.apply(this, arguments)\n\t\t\t} finally{\n\t\t\t\tpre && pre.apply(this, arguments)\n\t\t\t}\n\t\t}\n\t}\n}\n\nmodule.exports = fns\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\nvar fns = __webpack_require__(0)\nvar sessionId = +new Date()\nvar sessionKey = 'session_'\nconsole.log('[Session] Current ssid:', sessionId)\nvar cache = {\n\tsession: {\n\t\tset: function (k, v, asyncCB) {\n\t\t\treturn cache.set(sessionKey+k, v, -1*sessionId, asyncCB)\n\t\t},\n\t\tget: function (k, asyncCB) {\n\t\t\treturn cache.get(sessionKey+k, asyncCB)\n\t\t},\n\t\tremove: function (k, asyncCB) {\n\t\t\treturn cache.remove(sessionKey+k, asyncCB)\n\t\t}\n\t},\n\t/**\n\t * setter\n\t * @param {String} k      key\n\t * @param {Object} v      value\n\t * @param {Number} expire 过期时间，毫秒，为负数的时候表示为唯一session ID，为 true 表示保持上一次缓存时间\n\t * @param {Function} asyncCB optional, 是否异步、异步回调方法\n\t */\n\tset: function (k, v, expire, asyncCB) {\n\t\tif (fns.type(expire) == 'function') {\n\t\t\tasyncCB = expire\n\t\t\texpire = 0\n\t\t} else if (asyncCB && fns.type(asyncCB) != 'function') {\n\t\t\tasyncCB = noop\n\t\t}\n\t\tvar data = {\n\t\t\texpr: 0,\n\t\t\tdata: v\n\t\t}\n\t\tvar expireTime\n\t\t/**\n\t\t * 保持上次缓存时间\n\t\t */\n\t\tif (expire === true) {\n\t\t\tvar _cdata = wx.getStorageSync('_cache_' + k)\n\t\t\t// 上次没有缓存，本次也不更新\n\t\t\tif (!_cdata) return\n\t\t\t// 使用上次过期时间\n\t\t\tdata.expr = _cdata.expr || 0\n\t\t\texpireTime = 1\n\t\t}\n\t\tif (!expireTime) {\n\t\t\texpire = expire || 0\n\t\t\tif (expire > 0) {\n\t\t\t\tvar t = + new Date()\n\t\t\t\texpire = expire + t\n\t\t\t}\n\t\t\tdata.expr = +expire\n\t\t}\n\t\t/**\n\t\t * 根据异步方法决定同步、异步更新\n\t\t */\n\t\tif (asyncCB) {\n\t\t\twx.setStorage({\n\t\t\t\tkey: '_cache_' + k,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: function () {\n\t\t\t\t\tasyncCB()\n\t\t\t\t},\n\t\t\t\tfail: function (e) {\n\t\t\t\t\tasyncCB(e || `set \"${k}\" fail`)\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\twx.setStorageSync('_cache_' + k, data)\n\t\t}\n\t},\n\t/**\n\t * getter\n\t * @param {String} k      key\n\t * @param {Function} asyncCB optional, 是否异步、异步回调方法\n\t */\n\tget: function (k, asyncCB) {\n\t\tif (asyncCB) {\n\t\t\tif (fns.type(asyncCB) != 'function') asyncCB = noop\n\t\t\tvar errMsg = `get \"${k}\" fail`\n\t\t\twx.getStorage({\n\t\t\t\tkey: '_cache_' + k,\n\t\t\t\tsuccess: function (data) {\n\t\t\t\t\tif (data && data.data) {\n\t\t\t\t\t\tasyncCB(null, _resolve(k, data.data))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tasyncCB(data ? data.errMsg || errMsg : errMsg)\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tfail: function (e) {\n\t\t\t\t\tasyncCB(e || errMsg)\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\treturn _resolve(k, wx.getStorageSync('_cache_' + k))\n\t\t}\n\t},\n\tremove: function (k, asyncCB) {\n\t\tif (asyncCB) {\n\t\t\tif (fns.type(asyncCB) != 'function') asyncCB = noop\n\t\t\tvar errMsg = `remove \"${k}\" fail`\n\t\t\twx.removeStorage({\n\t\t\t\tkey: '_cache_' + k,\n\t\t\t\tsuccess: function () {\n\t\t\t\t\tasyncCB(null, true)\n\t\t\t\t},\n\t\t\t\tfail: function (e) {\n\t\t\t\t\tasyncCB(e || errMsg)\n\t\t\t\t}\n\t\t\t})\n\t\t} else {\n\t\t\treturn _resolve(k, wx.removeStorageSync('_cache_' + k))\n\t\t}\n\t}\n}\nfunction _resolve(k, v) {\n\tif (!v) return null\n\t// 永久存储\n\tif (!v.expr) return v.data\n\telse {\n\t\tif (v.expr < 0 && -1*v.expr == sessionId) {\n\t\t\t// session\n\t\t \treturn v.data\n\t\t} else if (v.expr > 0 && new Date() < v.expr) {\n\t\t\t// 普通存储\n\t\t\treturn v.data\n\t\t} else {\n\t\t \twx.removeStorage({\n\t\t \t\tkey: k\n\t\t \t})\n\t\t\treturn null\n\t\t}\n\t}\n}\nfunction noop() {}\nmodule.exports = cache\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar fns = __webpack_require__(0)\nvar _conf = {\n\tnameResolve: function () {}\n}\nmodule.exports = {\n\tset: function (k, v) {\n\t\tswitch(k) {\n\t\t\tcase 'resolvePath':\n\t\t\t\tif (fns.type(v) == 'function') {\n\t\t\t\t\t_conf.customRouteResolve = v\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tcase 'route':\n\t\t\t\tlet t = fns.type(v)\n\t\t\t\tif (t == 'string' || t == 'array') {\n\t\t\t\t\t\tlet routes = (t == 'string' ? [v]:v)\n\t\t\t\t\t\tlet mainRoute = routes[0]\n\t\t\t\t\t\troutes = routes.map(function (item) {\n\t\t\t\t\t\t\treturn new RegExp('^'+item\n\t\t\t\t\t\t\t\t.replace(/^\\/?/, '/?')\n\t\t\t\t\t\t\t\t.replace(/[\\.]/g, '\\\\.')\n\t\t\t\t\t\t\t\t.replace(/\\$page/g, '([\\\\w\\\\-]+)')\n\t\t\t\t\t\t\t\t//back .replace('$page', '([\\\\w\\\\-]+)')\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t})\n\t\t\t\t\t\t_conf.routeResolve = function (name) {\n\t\t\t\t\t\t\treturn mainRoute.replace(/\\$page/g, name)\n\t\t\t\t\t\t\t//back return mainRoute.replace('$page', name)\n\t\t\t\t\t\t}\n\t\t\t\t\t\t_conf.nameResolve = function (url) {\n\t\t\t\t\t\t\tvar n = ''\n\t\t\t\t\t\t\troutes.some(function (reg) {\n\t\t\t\t\t\t\t\tvar m = reg.exec(url)\t\n\t\t\t\t\t\t\t\tif (m) {\n\t\t\t\t\t\t\t\t\tn = m[1]\n\t\t\t\t\t\t\t\t\treturn true\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\treturn n\n\t\t\t\t\t\t}\n\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error('Illegal routes option:', v)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\t_conf[k] = v\n\t\t}\n\t},\n\tget: function (k) {\n\t\treturn _conf[k]\n\t}\n}\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n/**\n *  Simple Pub/Sub module\n *  @tencent/message and 减掉fns依赖\n **/\n\n\nfunction Message() {\n\tthis._evtObjs = {};\n}\nMessage.prototype.on = function (evtType, handler, _once) {\n\tif (!this._evtObjs[evtType]) {\n\t\tthis._evtObjs[evtType] = [];\n\t}\n\tthis._evtObjs[evtType].push({\n\t\thandler: handler,\n\t\tonce: _once\n\t})\n\tvar that = this\n\treturn function () {\n\t\tthat.off(evtType, handler)\n\t}\n}\nMessage.prototype.off = function (evtType, handler) {\n\tvar types;\n\tif (evtType) {\n\t\ttypes = [evtType];\n\t} else {\n\t\ttypes = Object.keys(this._evtObjs)\n\t}\n\tvar that = this;\n\ttypes.forEach(function (type) {\n\t\tif (!handler) {\n\t\t\t// remove all\n\t\t\tthat._evtObjs[type] = [];\n\t\t} else {\n\t\t\tvar handlers = that._evtObjs[type] || [],\n\t\t\t\tnextHandlers = [];\n\n\t\t\thandlers.forEach(function (evtObj) {\n\t\t\t\tif (evtObj.handler !== handler) {\n\t\t\t\t\tnextHandlers.push(evtObj)\n\t\t\t\t}\n\t\t\t})\n\t\t\tthat._evtObjs[type] = nextHandlers;\n\t\t}\n\t})\n\n\treturn this;\n}\nMessage.prototype.emit = function (evtType) {\n\tvar args = Array.prototype.slice.call(arguments, 1)\n\n\tvar handlers = this._evtObjs[evtType] || [];\n\thandlers.forEach(function (evtObj) {\n\t\tif (evtObj.once && evtObj.called) return\n\t\tevtObj.called = true\n\t\ttry {\n\t\t\tevtObj.handler && evtObj.handler.apply(null, args);\n\t\t} catch(e) {\n\t\t\tconsole.error(e.stack || e.message || e)\n\t\t}\n\t})\n}\nMessage.prototype.assign = function (target) {\n\tvar msg = this;\n\t['on', 'off', 'emit', 'assign'].forEach(function (name) {\n\t\tvar method = msg[name]\n\t\ttarget[name] = function () {\n\t\t\treturn method.apply(msg, arguments)\n\t\t}\n\t})\n}\n/**\n *  Global Message Central\n **/\n;(new Message()).assign(Message)\nmodule.exports = Message;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n/**\n * 对wx.navigateTo、wx.redirectTo、wx.navigateBack的包装，在它们的基础上添加了事件\n */\nvar Message = __webpack_require__(3)\nvar exportee = module.exports = new Message()\nvar timer, readyTimer, pending\n\nexportee.on('page:ready', function () {\n\treadyTimer = setTimeout(function () {\n\t\tpending = false\n\t}, 100)\n})\nfunction route(type, cfg, args) {\n\tif (pending) return\n\tpending = true\n\tclearTimeout(timer)\n\tclearTimeout(readyTimer)\n\t/**\n\t * 2s内避免重复的跳转\n\t */\n\ttimer = setTimeout(function () {\n\t\tpending = false\n\t}, 2000)\n\texportee.emit('navigateTo', cfg.url)\n\n\t// 会存在不兼容接口，例如：reLaunch\n\tif (wx[type]) {\n\t\treturn wx[type].apply(wx, args)\n\t}\n}\nexportee.navigateTo = function (cfg) {\n\treturn route('navigateTo', cfg, arguments)\n}\nexportee.redirectTo = function (cfg) {\n\treturn route('redirectTo', cfg, arguments)\n}\nexportee.switchTab = function (cfg) {\n\treturn route('switchTab', cfg, arguments)\n}\nexportee.reLaunch = function (cfg) {\n\treturn route('reLaunch', cfg, arguments)\n}\nexportee.navigateBack = function () {\n  return wx.navigateBack.apply(wx, arguments)\n}\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nvar cache = __webpack_require__(1)\nvar redirector = __webpack_require__(4)\nvar conf = __webpack_require__(2)\nvar fns = __webpack_require__(0)\nvar navigate = route({type: 'navigateTo'})\nvar redirect = route({type: 'redirectTo'})\nvar switchTab = route({type: 'switchTab'})\nvar reLaunch = route({type: 'reLaunch'})\nvar routeMethods = {navigate, redirect, switchTab, reLaunch}\nvar bindNavigate = clickDelegate('navigate')\nvar bindRedirect = clickDelegate('redirect')\nvar bindSwitch = clickDelegate('switchTab')\nvar bindReLaunch = clickDelegate('reLaunch')\nvar channel = {}\nvar dispatcher\nvar getRef\n\nmodule.exports = {\n\tchannel,\n\tdispatcher: function (d) {\n\t\tdispatcher = d\n\t},\n\tref: function (fn) {\n\t\tgetRef = fn\n\t},\n\tmount: function (e) {\n\t\tvar payload = e.detail\n\t\tswitch(payload.type) {\n\t\t\tcase 'attached':\n\t\t\t\tlet ref = getRef && getRef(payload.id)\n\t\t\t\tif (!ref) return\n\n\t\t\t\tlet refName = ref._$ref\n\t\t\t\tif (refName && this.$refs) {\n\t\t\t\t\tthis.$refs[refName] = ref\n\t\t\t\t}\n\t\t\t\tref._$attached(this)\n\t\t\t\tbreak\n\t\t\tcase 'event:call':\n\t\t\t\tlet method = this[payload.method]\n\t\t\t\tmethod && method.apply(this, payload.args)\n\t\t\tdefault:\n\t\t\t\tbreak\n\t\t}\n\t},\n\tredirectDelegate: function (emitter, dispatcher) {\n\t\t;['navigateTo', 'redirectTo', 'switchTab', 'reLaunch'].forEach(function (k) {\n\t\t\temitter.on(k, function (url) {\n\t\t\t\tvar name = getPageName(url)\n\t\t\t\tname && dispatcher.emit(k+':'+name, url, fns.queryParse(url.split('?')[1]))\n\t\t\t})\n\t\t})\n\t},\n\tmethods: function (ctx) {\n\t\t/**\n\t\t * 缓存\n\t\t */\n\t\tctx.$cache = cache\n\t\tctx.$session = cache.session\n\t\t/**\n\t\t * 存一次，取一次\n\t\t */\n\t\tctx.$put = put\n\t\t/**\n\t\t * 只能被取一次\n\t\t */\n\t\tctx.$take = take\n\t\t/**\n\t\t * 实例引用集合\n\t\t */\n\t\tctx.$refs = {}\n\n\t\t/**\n\t\t * 路由方法\n\t\t */\n\t\tctx.$route = ctx.$navigate = navigate\n\t\tctx.$redirect = redirect\n\t\tctx.$switch = switchTab\n\t\tctx.$launch = reLaunch\n\t\tctx.$back = back\n\t\t/**\n\t\t * 页面预加载\n\t\t */\n\t\tctx.$preload = preload\n\t\t/**\n\t\t * 点击跳转代理\n\t\t */\n\t\tctx.$bindRoute = ctx.$bindNavigate = bindNavigate\n\t\tctx.$bindRedirect = bindRedirect\n\t\tctx.$bindSwitch = bindSwitch\n\t\tctx.$bindReLaunch = bindReLaunch\n\t\t/**\n\t\t * 页面信息\n\t\t */\n\t\tctx.$curPage = getPage\n\t\tctx.$curPageName = curPageName\n\t},\n\tgetPageName\n}\n/**\n * Navigate handler\n */\nfunction route ({type}) {\n\t// url: $page[?name=value]\n\treturn function (url, config) {\n\t\tvar parts = url.split(/\\?/)\n\t\tvar pagepath = parts[0]\n\t\tif (/^[\\w\\-]+$/.test(pagepath)) {\n\t\t\tpagepath = (conf.get('customRouteResolve') || conf.get('routeResolve'))(pagepath)\n\t\t}\n\t\tif (!pagepath) {\n\t\t\tthrow new Error('Invalid path:', pagepath)\n\t\t}\n\t\tconfig = config || {}\n\t\t// append querystring\n\t\tconfig.url = pagepath + (parts[1] ? '?' + parts[1] : '')\n\t\tredirector[type](config)\n\t}\n}\n\nfunction clickDelegate(type) {\n\tvar _route = routeMethods[type]\n\treturn function (e) {\n\t\tif (!e) return\n\t\tvar dataset = e.currentTarget.dataset\n\t\tvar before = dataset.before\n\t\tvar after = dataset.after\n\t\tvar url = dataset.url\n\t\tvar ctx = this\n\t\ttry {\n\t\t\tif (ctx && before && ctx[before]) ctx[before].call(ctx, e)\n\t\t} finally {\n\t\t\tif (!url) return\n\t\t\t_route(url)\n\t\t\tif (ctx && after && ctx[after]) ctx[after].call(ctx, e)\n\t\t}\n\t}\n}\n\nfunction back(delta) {\n\twx.navigateBack({\n\t\tdelta: delta || 1\n\t})\n}\nfunction preload(url){\n\tvar name = getPageName(url)\n\tname && dispatcher && dispatcher.emit('preload:'+name, url, fns.queryParse(url.split('?')[1]))\n}\nfunction getPage() {\n\treturn getCurrentPages().slice(0).pop()\n}\nfunction getPageName(url) {\n\tvar m = /^[\\w\\-]+(?=\\?|$)/.exec(url)\n\treturn m ? m[0] : conf.get('nameResolve')(url)\n}\nfunction curPageName () {\n\tvar route = getPage().route\n\tif (!route) return ''\n\treturn getPageName(route)\n}\nfunction put (key, value) {\n\tchannel[key] = value\n\treturn this\n}\nfunction take (key) {\n\tvar v = channel[key]\n\t// 释放引用\n\tchannel[key] = null\n\treturn v\n}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\nvar fns = __webpack_require__(0)\nvar bridge = __webpack_require__(5)\nvar cache = __webpack_require__(1)\nvar conf = __webpack_require__(2)\nvar redirector = __webpack_require__(4)\nvar message = __webpack_require__(3)\nvar modules = {\n\tfns, redirector, cache, message, dispatcher,\n\tchannel: bridge.channel\n}\nvar dispatcher\n/**\n * Component constructor\n */\nvar refs = {}\nvar cid = 0\nfunction component(def) {\n\tif (!def) {\n\t\tconsole.error(`Illegal component options.`)\n\t\tdef = {}\n\t}\n\t// extend page config\n\tvar extendComponentBefore = conf.get('extendComponentBefore')\n\textendComponentBefore && extendComponentBefore(def, modules)\n\n\tdef.created = fns.wrapFun(def.created, function () {\n\t\tbridge.methods(this, dispatcher)\n\t})\n\tdef.attached = fns.wrapFun(def.attached, function () {\n\t\tvar id = ++cid\n\t\tthis.$id = id\n\t\trefs[id] = this\n\t\tthis._$ref = this.properties.ref || this.properties._ref\n\t\tthis.triggerEvent('ing', {\n\t\t\tid: this.$id,\n\t\t\ttype: 'attached'\n\t\t})\n\t})\n\tdef.detached = fns.wrapFun(def.detached, function () {\n\t\tdelete refs[this.$id]\n\t\tvar $refs = this.$parent && this.$parent.$refs\n\t\tvar refName = this._$ref\n\t\tif (refName && $refs) {\n\t\t\tdelete $refs[refName]\n\t\t}\n\t\tthis.$parent = null\n\t})\n\tdef.properties = fns.extend({}, def.properties, {\n    'ref': {\n    \ttype: String,\n      value: '',\n      observer: function(next) {\n      \t/**\n      \t * 支持动态 ref\n      \t */\n      \tif (this._$ref !== next) {\n\t\t\t\t\tvar $refs = this.$parent && this.$parent.$refs\n\t\t\t\t\tif ($refs) {\n\t\t\t\t\t\tlet ref = $refs[this._$ref]\n\t\t\t\t\t\tdelete $refs[this._$ref]\n\t\t\t\t\t\tthis._$ref = next\n\t\t\t\t\t\tif (ref && next) {\n\t\t\t\t\t\t\t$refs[next]\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n      \t}\n      }\n    },\n\t})\n\tdef.methods = fns.extend({}, def.methods, {\n\t\t// 与旧的一致\n\t\t$globalData: function(){ \n\t\t\treturn getApp().globalData\n\t\t},\n\n\t\t$set: function () {\n\t\t\treturn this.setData.apply(this, arguments)\n\t\t},\n\t\t$data: function () {\n\t\t\treturn this.data\n\t\t},\n\t\t$emit: function () {\n\t\t\tif (!dispatcher) return\n\t\t\treturn dispatcher.emit.apply(dispatcher, arguments)\n\t\t},\n\t\t$on: function () {\n\t\t\tif (!dispatcher) return function () {}\n\t\t\treturn dispatcher.on.apply(dispatcher, arguments)\n\t\t},\n\t\t$off: function () {\n\t\t\tif (!dispatcher) return\n\t\t\treturn dispatcher.off.apply(dispatcher, arguments)\n\t\t},\n\t\t$call: function (method) {\n\t\t\tvar args = [].slice.call(arguments, 1)\n\t\t\tthis.triggerEvent('ing', {\n\t\t\t\tid: this.$id,\n\t\t\t\ttype: 'event:call',\n\t\t\t\tmethod,\n\t\t\t\targs\n\t\t\t})\n\t\t},\n\t\t/**\n\t\t * 由父组件调用\n\t\t */\n\t\t_$attached: function (parent) {\n\t\t\tthis.$root = parent.$root || parent\n\t\t\tthis.$parent = parent\n\t\t},\n\t\t$: bridge.mount\n\t})\n\n\tComponent(def)\n}\ncomponent.getRef = function (id) {\n\treturn refs[id]\n}\nbridge.ref(component.getRef)\ncomponent.dispatcher = function (d) {\n\tdispatcher = d\n}\nComponent.C = component\nmodule.exports = component\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\n\n\nvar fns = __webpack_require__(0)\nvar message = __webpack_require__(3)\nvar redirector = __webpack_require__(4)\nvar cache = __webpack_require__(1)\nvar C = __webpack_require__(6)\nvar bridge = __webpack_require__(5)\nvar _conf = __webpack_require__(2)\nvar dispatcher = new message()\nvar hasPageLoaded = 0\nvar isAppLaunched = 0\nvar isAppShowed = 0\nvar hideTime = 0\nvar modules = {\n\tfns, redirector, cache, message, dispatcher,\n\tchannel: bridge.channel\n}\nbridge.ref(C.getRef)\nbridge.dispatcher(dispatcher)\nC.dispatcher(dispatcher)\nfunction WXBoot(name, option) {\n\tif (fns.type(name) == 'object') {\n\t\toption = name\n\t\tname = option.name || '_unknow'\n\t}\n\t// page internal message\n\tvar emitter = new message()\n\n\t// extend page config\n\tvar extendPageBefore = _conf.get('extendPageBefore')\n\textendPageBefore && extendPageBefore(name, option, modules)\n\n\t// mixin component defs\n\t\n\t// C.use(option, option.comps, `Page[${name}]`, emitter)\n\tif (option.onNavigate){\n\t\tlet onNavigateHandler = function (url, query) {\n\t\t\toption.onNavigate({url, query})\n\t\t}\n\t\tconsole.log(`Page[${name}] define \"onNavigate\".`)\n\t\tdispatcher.on('navigateTo:'+name, onNavigateHandler)\n\t\tdispatcher.on('redirectTo:'+name, onNavigateHandler)\n\t\tdispatcher.on('switchTab:'+name, onNavigateHandler)\n\t\tdispatcher.on('reLaunch:'+name, onNavigateHandler)\n\t}\n\t/**\n\t * Preload lifecycle method\n\t */\n\tif (option.onPreload){\n\t\tconsole.log(`Page[${name}] define \"onPreload\".`)\n\t\tdispatcher.on('preload:'+name, function (url, query) {\n\t\t\toption.onPreload({url, query})\n\t\t})\n\t}\n\t/**\n\t * Instance props\n\t */\n\toption.$state = {\n\t\t// 是否小程序被打开首页启动页面\n\t\tfirstOpen: false\n\t}\n\toption.$emitter = emitter\n\tbridge.methods(option)\n\n\t/**\n\t * Cross pages message methods\n\t */\n\toption.$on = function () {\n\t\treturn dispatcher.on.apply(dispatcher, arguments)\n\t}\n\toption.$emit = function () {\n\t\treturn dispatcher.emit.apply(dispatcher, arguments)\n\t}\n\toption.$off = function () {\n\t\treturn dispatcher.off.apply(dispatcher, arguments)\n\t}\n\t/**\n\t * 父子通信枢纽模块\n\t */\n\toption.$ = bridge.mount\n\t/**\n\t * setData wrapper, for component setData with prefix\n\t * @param {String} prefix prefix of component's data\n\t * @param {Object} data\n\t */\n\toption.$setData = function (prefix, data) {\n\t\tif (fns.type(prefix) == 'string') {\n\t\t\tvar props = {}\n\t\t\tfns.objEach(data, function (k,v) {\n\t\t\t\tprops[prefix + '.' + k] = v\n\t\t\t})\n\t\t\t\n\t\t\treturn this.setData(objToPath(props))\n\t\t\t//back return this.setData(props)\n\t\t} else if (fns.type(prefix) == 'object') {\n\t\t\treturn this.setData(objToPath(prefix))\n\t\t\t//back return this.setData(props)\n\t\t\t\n\t\t}\n\t}\n\t/**\n\t * AOP life-cycle methods hook\n\t */\n\toption.onLoad = fns.wrapFun(option.onLoad, function() {\n\t\t// After onLoad, onAwake is valid if defined\n\t\toption.onAwake && message.on('app:sleep', (t) => {\n\t\t\toption.onAwake.call(this, t)\n\t\t})\n\t\tif (!hasPageLoaded) {\n\t\t\thasPageLoaded = true\n\n\t\t\tlet $state = this.$state\n\t\t\t$state.firstOpen = true\n\t\t}\n\t})\n\toption.onReady = fns.wrapFun(option.onReady, function () {\n\t\tredirector.emit('page:ready')\n\t})\n\n\t// call on launch\n\tif (option.onPageLaunch) {\n\t\toption.onPageLaunch()\n\t}\n\tif (option.onAppLaunch) {\n\t\tisAppLaunched ? option.onAppLaunch.apply(option, isAppLaunched) : dispatcher.on('app:launch', function (args) {\n\t\t\toption.onAppLaunch.apply(option, args)\n\t\t})\n\t}\n\tif (option.onAppShow) {\n\t\tisAppLaunched ? option.onAppShow.apply(option, isAppLaunched) : dispatcher.on('app:show', function (args) {\n\t\t\toption.onAppShow.apply(option, args)\n\t\t})\n\t}\n\n\t//back option增加this.upData this.Empty\n\toption.$upData = function (data) {\n\t\t\treturn this.setData(objToPath(data));\n\t}\n\toption.Empty = Empty;\n\toption.$App = getApp();\n\toption.$globalData = function(){ \n\t\treturn option.$App.globalData\n\t};\n\toption.$bindGlobalData = function(callback){ \t\n\t\t\tthis.setData({\n\t\t\t\tglobalData:JSON.parse(JSON.stringify(option.$globalData()))\n\t\t\t})\n\t\t\tobserveGlobalData(option.$globalData(),this,callback);\n\t};\n\toption.$getStore = function(storeName){ \n\t\treturn option.$App[storeName] = option.$App[storeName]||{} ; \n\t};\n\toption.$bindStore= function(storeName,callback){ \t\n\t\toption.$App[storeName] = option.$App[storeName]||{} ; \n\t\t\tthis.setData({\n\t\t\t\t[storeName]:JSON.parse(JSON.stringify(option.$App[storeName]))\n\t\t\t})\n\t\t\tobserveByStoreName(storeName,option.$App[storeName],this,callback);\n\t};\n\toption.$bindPageStore= function(pageStore,callback){ \t\n\t\t\n\t\t\tthis.setData(JSON.parse(JSON.stringify(pageStore)))\n\t\t\tobservePageStore(pageStore,this,callback);\n\t};\n\toption.$bindFunction= function(functionName ,callback){ \t\n\t\t\t//动态生成 绑定方法方法\n\t\t\tbindFunction(functionName ,callback,this);\n\t};\n\n\toption.$bindApi= function(functionStore){ \n\t\tbindApi(functionStore,this)\n\t};\n\t//绑定页面\n\tvar pageApi = _conf.get('pageApi')\n\tpageApi &&\tbindApi(pageApi,option)\n\t\n\n\t// extend page config\n\tvar extendPageAfter = _conf.get('extendPageAfter')\n\textendPageAfter && extendPageAfter(name, option, modules)\n\t// register page\n\tPage(option)\n\treturn option;\n}\n/**\n * 由重定向模块转发到页面内派发器\n */\nbridge.redirectDelegate(redirector, dispatcher)\n/**\n * Application wrapper\n */\nfunction Application (option) {\n\n\tif (!option.config || !option.config.route || !option.config.route.length) {\n\t\tthrow new Error('config.route is necessary !')\n\t}\n\tif (option.config) {\n\t\tWXBoot.config(option.config)\n\t}\n\tvar ctx = option\n\t/**\n\t * APP sleep logical\n\t */\n\toption.onShow = option.onShow ? fns.wrapFun(option.onShow, appShowHandler) : appShowHandler\n\toption.onHide = option.onHide ? fns.wrapFun(option.onHide, appHideHandler) : appHideHandler\n\toption.onLaunch = option.onLaunch ? fns.wrapFun(option.onLaunch, appLaunchHandler) : appLaunchHandler\n\toption.onLaunch = fns.wrapFun(option.onLaunch, function () {\n\t\tctx = this\n\t})\n\tif (option.onAwake) {\n\t\tmessage.on('app:sleep', function(t){\n\t\t\toption.onAwake.call(ctx, t)\n\t\t})\n\t}\n\t/**\n\t * Use app config\n\t */\n\tApp(option)\n}\nfunction appLaunchHandler() {\n\tisAppLaunched = [].slice.call(arguments)\n\tmessage.emit('app:launch', isAppLaunched)\n}\nfunction appShowHandler () {\n\ttry {\n\t\tif (!isAppShowed) {\n\t\t\t// call onAppShow only once\n\t\t\tisAppShowed = [].slice.call(arguments)\n\t\t\tmessage.emit('app:show', isAppShowed)\n\t\t}\n\t} finally {\n\t\tif (!hideTime) return\n\t\tvar t = hideTime\n\t\thideTime = 0\n\t\tmessage.emit('app:sleep', new Date() - t)\n\t}\n}\nfunction appHideHandler() {\n\thideTime = new Date()\n}\n\nPage.P = WXBoot\nPage.C = Component.C = WXBoot.C = WXBoot.Comp = WXBoot.Component = C\nPage.A = App.A = WXBoot.A = WXBoot.App = WXBoot.Application = Application\nWXBoot.redirector = redirector\nWXBoot.message = message\nWXBoot.cache = cache\nWXBoot.fns = fns\nWXBoot.getPageName = bridge.getPageName\n\n/**\n * Config handler\n */\n\nWXBoot.config = function (key, value) {\n\tif (fns.type(key) == 'object') {\n\t\tfns.objEach(key, function (k, v) {\n\t\t\t_conf.set(k, v)\n\t\t})\n\t} else {\n\t\t_conf.set(key, value)\n\t}\n\treturn this\n}\nmessage.assign(WXBoot)\nmessage.assign(C)\nmessage.assign(Application)\nmodule.exports = WXBoot\n\n\n/***/ })\n/******/ ]);\n\n\n\nfunction observeGlobalData(globalData, _self,callback) {\n\tconst oba = getObaa(globalData,null,_self,callback)\n\t\t//动态生成 添加新属性方法\n\t\tif (!_self.$setGlobalData) {\n\t\t\t_self.$setGlobalData= function ( prop, val) {\n\t\t\t\tobaa.set(globalData, prop, val, oba)\n\t\t\t}\n\t\t}\n}\n\n\nfunction observeByStoreName(storeName,store, _self,callback) {\n\tconst oba = getObaa(store,storeName,_self,callback)\n\t//动态生成 添加新属性方法\n  if (!_self['$setBind'+storeName.substring(0, 1).toUpperCase() + storeName.substring(1)]) {\n    _self['$setBind'+storeName.substring(0, 1).toUpperCase() + storeName.substring(1)] = function ( prop, val) {\n      obaa.set(store, prop, val, oba)\n    }\n  }\n}\n\nfunction observePageStore(pageStore, _self,callback) {\n  const oba = getObaa(pageStore,null,_self,callback)\n\t//动态生成 添加新属性方法\n\tif (!_self.$setPageStore) {\n\t\t_self.$setPageStore= function ( prop, val) {\n\t\t\tobaa.set(pageStore, prop, val, oba)\n\t\t}\n\t}\n\n}\nfunction getObaa(store,storeName,_self,callback){\n\tconst oba = obaa(store, (prop, value, old, path) => {\n    let patch = {}\n    if (prop.indexOf('Array-push') === 0) {\n      let dl = value.length - old.length\n      for (let i = 0; i < dl; i++) {\n        patch[fixPath(path + '-' + (old.length + i))] = value[(old.length + i)]\n      }\n    } else if (prop.indexOf('Array-') === 0) {\n      patch[fixPath(path)] = value\n    } else {\n      patch[fixPath(path + '-' + prop)] = value\n\t\t}\n\t\tif(storeName){\n\t\t_self.$setData(storeName,patch)\n\t\t} else {\n\t\t_self.$setData(patch)\n\t\t}\n\t\t//回调函数\n\t\tif(Object.prototype.toString.call(callback)==\"[object Function]\"){\n\t\tcallback(patch);\n\t\t}\n\t})\t\n\treturn oba;\n}\n\nfunction bindFunction(functionName ,callback,_self){ \t\n\t//动态生成 绑定方法方法\n\tif (!_self[functionName]) {\n\t\t_self[functionName]= callback\n\t\tconsole.log(functionName+\"方法绑定成功\")\n\t} else {\n\tconsole.log(\"绑定失败 该方法已存在。\")\n\t}\n};\n\n\nfunction bindApi(functionStore,_self){ \t\n\tif(Object.prototype.toString.call(functionStore)!=\"[object Object]\"){\n\t\tconsole.log(\"functionStore 格式错误\");\n\t\treturn;\n\t}\n\tfor (const functionName in functionStore) {\n\t\tif (functionStore.hasOwnProperty(functionName)) {\n\t\t\tconst callback = functionStore[functionName];\n\t\t\t\t//动态生成 绑定方法方法\n\t\t\t\tbindFunction(functionName ,callback,_self);\n\t\t}\n\t}\t\t\n};\n","function t(r){return(t=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&\"function\"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?\"symbol\":typeof t})(r)}function r(t,r){return function(t){if(Array.isArray(t))return t}(t)||function(t,r){if(\"undefined\"==typeof Symbol||!(Symbol.iterator in Object(t)))return;var n=[],e=!0,o=!1,a=void 0;try{for(var u,i=t[Symbol.iterator]();!(e=(u=i.next()).done)&&(n.push(u.value),!r||n.length!==r);e=!0);}catch(t){o=!0,a=t}finally{try{e||null==i.return||i.return()}finally{if(o)throw a}}return n}(t,r)||function(t,r){if(!t)return;if(\"string\"==typeof t)return n(t,r);var e=Object.prototype.toString.call(t).slice(8,-1);\"Object\"===e&&t.constructor&&(e=t.constructor.name);if(\"Map\"===e||\"Set\"===e)return Array.from(t);if(\"Arguments\"===e||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(e))return n(t,r)}(t,r)||function(){throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\")}()}function n(t,r){(null==r||r>t.length)&&(r=t.length);for(var n=0,e=new Array(r);n<r;n++)e[n]=t[n];return e}function e(t){return Array.isArray(t)}function o(r){return\"object\"===t(r)&&null!==r&&!e(r)}var a=function t(r,n,a){var c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};r.forEach((function(r,f){if(r!==u){var y=\"\".concat(n,\"[\").concat(f,\"]\");o(r)?c.arrObjPath?i(r,y+(Object.keys(r).every((function(t){return/^\\[\\d+]$/.test(t)||c.arrObjPath}))?\"\":\".\"),a,c):i(r,y+\".\",a,c):e(r)?t(r,y,a):a[y]=r}}))},u=Symbol(\"updata empty array item\"),i=function t(n){var u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"\",i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};\"string\"!=typeof u&&(c=u,u=\"\");var f=!1;if(c.arrObjPath)if(Object.keys(n).every((function(t){return/^\\[\\d+]$/.test(t)})))f=!0;else{if(Object.keys(n).some((function(t){return/^\\[\\d+]$/.test(t)})))throw new Error(\"wx-updata: 数组路径对象需要每个属性都是对象路径 [数组下标] 形式\");f=!1}for(var y=0,l=Object.entries(n);y<l.length;y++){var b=r(l[y],2),s=b[0],h=b[1],v=\"\"===u?s:u.endsWith(\"].\")||f?\"\".concat(u).concat(s):\"\".concat(u,\".\").concat(s);o(h)?t(h,v,i,c):e(h)?a(h,v,i,c):i[v]=h}return i},c=function(t,r){var n=t;return function(t){return t.upData=function(t,n){var e=i(t,{arrObjPath:r.arrObjPath});return r.debug&&console.log(\"转化后效果:\",e),this.setData(e,n)},n(t)}};if (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });Object.defineProperty(exports, 'Empty', { enumerable: true, configurable: true, get: function() { return u; } });Object.defineProperty(exports, 'objToPath', { enumerable: true, configurable: true, get: function() { return i; } });Object.defineProperty(exports, 'updataInit', { enumerable: true, configurable: true, get: function() { return c; } });\n//# sourceMappingURL=wx-updata.js.map\n","/* obaa 1.0.0\n * By dntzhang\n * Github: https://github.com/Tencent/omi\n * MIT Licensed.\n */\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function obaa(target, arr, callback) {\n  var _observe = function (target, arr, callback) {\n    //if (!target.$observer) target.$observer = this\n    var $observer = this\n    var eventPropArr = []\n    if (obaa.isArray(target)) {\n      if (target.length === 0) {\n        $observer.track(target)\n      }\n      $observer.mock(target)\n    }\n    if (target && typeof target === 'object' && Object.keys(target).length === 0) {\n      $observer.track(target)\n    }\n    for (var prop in target) {\n      if (target.hasOwnProperty(prop)) {\n        if (callback) {\n          if (obaa.isArray(arr) && obaa.isInArray(arr, prop)) {\n            eventPropArr.push(prop)\n            $observer.watch(target, prop)\n          } else if (obaa.isString(arr) && prop == arr) {\n            eventPropArr.push(prop)\n            $observer.watch(target, prop)\n          }\n        } else {\n          eventPropArr.push(prop)\n          $observer.watch(target, prop)\n        }\n      }\n    }\n    $observer.target = target\n    if (!$observer.propertyChangedHandler)\n      $observer.propertyChangedHandler = []\n    var propChanged = callback ? callback : arr\n    $observer.propertyChangedHandler.push({\n      all: !callback,\n      propChanged: propChanged,\n      eventPropArr: eventPropArr\n    })\n  }\n  _observe.prototype = {\n    onPropertyChanged: function (prop, value, oldValue, target, path) {\n      if (value !== oldValue && (!(nan(value) && nan(oldValue))) && this.propertyChangedHandler) {\n        var rootName = obaa._getRootName(prop, path)\n        for (\n          var i = 0, len = this.propertyChangedHandler.length;\n          i < len;\n          i++\n        ) {\n          var handler = this.propertyChangedHandler[i]\n          if (\n            handler.all ||\n            obaa.isInArray(handler.eventPropArr, rootName) ||\n            rootName.indexOf('Array-') === 0\n          ) {\n            handler.propChanged.call(this.target, prop, value, oldValue, path)\n          }\n        }\n      }\n      if (prop.indexOf('Array-') !== 0 && typeof value === 'object') {\n        this.watch(target, prop, target.$observeProps.$observerPath)\n      }\n    },\n    mock: function (target) {\n      var self = this\n      obaa.methods.forEach(function (item) {\n        target[item] = function () {\n          var old = Array.prototype.slice.call(this, 0)\n          var result = Array.prototype[item].apply(\n            this,\n            Array.prototype.slice.call(arguments)\n          )\n          if (new RegExp('\\\\b' + item + '\\\\b').test(obaa.triggerStr)) {\n            for (var cprop in this) {\n              if (\n                this.hasOwnProperty(cprop) &&\n                !obaa.isFunction(this[cprop])\n              ) {\n                self.watch(this, cprop, this.$observeProps.$observerPath)\n              }\n            }\n            //todo\n            self.onPropertyChanged(\n              'Array-' + item,\n              this,\n              old,\n              this,\n              this.$observeProps.$observerPath\n            )\n          }\n          return result\n        }\n        target[\n          'pure' + item.substring(0, 1).toUpperCase() + item.substring(1)\n        ] = function () {\n          return Array.prototype[item].apply(\n            this,\n            Array.prototype.slice.call(arguments)\n          )\n        }\n      })\n    },\n    watch: function (target, prop, path) {\n      if (prop === '$observeProps' || prop === '$observer') return\n      if (obaa.isFunction(target[prop])) return\n      if (!target.$observeProps) {\n        Object.defineProperty(target, '$observeProps', {\n          configurable: true,\n          enumerable: false,\n          writable: true,\n          value: {}\n        })\n      }\n      if (path !== undefined) {\n        target.$observeProps.$observerPath = path\n      } else {\n        target.$observeProps.$observerPath = '#'\n      }\n      var self = this\n      var currentValue = (target.$observeProps[prop] = target[prop])\n      Object.defineProperty(target, prop, {\n        get: function () {\n          return this.$observeProps[prop]\n        },\n        set: function (value) {\n          var old = this.$observeProps[prop]\n          this.$observeProps[prop] = value\n          self.onPropertyChanged(\n            prop,\n            value,\n            old,\n            this,\n            target.$observeProps.$observerPath\n          )\n        }\n      })\n      if (typeof currentValue == 'object') {\n        if (obaa.isArray(currentValue)) {\n          this.mock(currentValue)\n          //为0，就不会进下面的 for 循环，就不会执行里面的 watch，就不会有 $observeProps 属性\n          if (currentValue.length === 0) {\n            this.track(currentValue, prop, path)\n          }\n        }\n        if (currentValue && Object.keys(currentValue).length === 0) {\n          this.track(currentValue, prop, path)\n        }\n        for (var cprop in currentValue) {\n          if (currentValue.hasOwnProperty(cprop)) {\n            this.watch(\n              currentValue,\n              cprop,\n              target.$observeProps.$observerPath + '-' + prop\n            )\n          }\n        }\n      }\n    },\n    track: function(obj, prop, path) {\n      if (obj.$observeProps) {\n        return\n      }\n      Object.defineProperty(obj, '$observeProps', {\n        configurable: true,\n        enumerable: false,\n        writable: true,\n        value: {}\n      })\n      if (path !== undefined && path !== null) {\n        obj.$observeProps.$observerPath = path + '-' + prop\n      } else {\n        if (prop !== undefined && prop !== null) {\n          obj.$observeProps.$observerPath = '#' + '-' + prop\n        } else {\n          obj.$observeProps.$observerPath = '#'\n        }\n      }\n    }\n  }\n  return new _observe(target, arr, callback)\n};exports.default = obaa\n\nobaa.methods = [\n  'concat',\n  'copyWithin',\n  'entries',\n  'every',\n  'fill',\n  'filter',\n  'find',\n  'findIndex',\n  'forEach',\n  'includes',\n  'indexOf',\n  'join',\n  'keys',\n  'lastIndexOf',\n  'map',\n  'pop',\n  'push',\n  'reduce',\n  'reduceRight',\n  'reverse',\n  'shift',\n  'slice',\n  'some',\n  'sort',\n  'splice',\n  'toLocaleString',\n  'toString',\n  'unshift',\n  'values',\n  'size'\n]\nobaa.triggerStr = [\n  'concat',\n  'copyWithin',\n  'fill',\n  'pop',\n  'push',\n  'reverse',\n  'shift',\n  'sort',\n  'splice',\n  'unshift',\n  'size'\n].join(',')\n\nobaa.isArray = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]'\n}\n\nobaa.isString = function (obj) {\n  return typeof obj === 'string'\n}\n\nobaa.isInArray = function (arr, item) {\n  for (var i = arr.length; --i > -1;) {\n    if (item === arr[i]) return true\n  }\n  return false\n}\n\nobaa.isFunction = function (obj) {\n  return Object.prototype.toString.call(obj) == '[object Function]'\n}\n\nobaa._getRootName = function (prop, path) {\n  if (path === '#') {\n    return prop\n  }\n  return path.split('-')[1]\n}\n\nobaa.add = function (obj, prop) {\n  var $observer = obj.$observer\n  $observer.watch(obj, prop)\n}\n\nobaa.set = function (obj, prop, value, oba) {\n  // if (exec) {\n  //   obj[prop] = value\n  // }\n  if (obj[prop] === undefined) {\n    var $observer = obj.$observer || oba\n    $observer.watch(obj, prop, obj.$observeProps.$observerPath)\n  }\n  //if (!exec) {\n  obj[prop] = value\n  //}\n}\n\nArray.prototype.size = function (length) {\n  this.length = length\n}\n\nfunction nan(value) {\n  return typeof value === \"number\" && isNaN(value)\n}\n\n","const OBJECTTYPE = '[object Object]'\nconst ARRAYTYPE = '[object Array]'\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getUsing(data, paths) {\n  if(!paths) return {}\n  const obj = {}\n  paths.forEach((path, index) => {\n    const isPath = typeof path === 'string'\n    if (!isPath) {\n      const key = Object.keys(path)[0]\n      const value = path[key]\n      if (typeof value !== 'string') {\n\n        const tempPath = value[0]\n        if (typeof tempPath === 'string') {\n          const tempVal = getTargetByPath(data, tempPath)\n          obj[key] = value[1] ? value[1](tempVal) : tempVal\n        } else {\n          const args = []\n          tempPath.forEach(path => {\n            args.push(getTargetByPath(data, path))\n          })\n          obj[key] = value[1].apply(null, args)\n        }\n\n      }\n    }\n  })\n  return obj\n};exports.getUsing = getUsing\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getTargetByPath(origin, path) {\n  const arr = path\n    .replace(/]/g, '')\n    .replace(/\\[/g, '.')\n    .split('.')\n  let current = origin\n  for (let i = 0, len = arr.length; i < len; i++) {\n    current = current[arr[i]]\n  }\n  return current\n};exports.getTargetByPath = getTargetByPath\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getPath(obj) {\n  if (Object.prototype.toString.call(obj) === '[object Array]') {\n    const result = {}\n    obj.forEach(item => {\n      if (typeof item === 'string') {\n        result[item] = true\n      } else {\n        const tempPath = item[Object.keys(item)[0]]\n        if (typeof tempPath === 'string') {\n          result[tempPath] = true\n        } else if (typeof tempPath[0] === 'string') {\n          result[tempPath[0]] = true\n        } else {\n          tempPath[0].forEach(path => (result[path] = true))\n        }\n      }\n    })\n    return result\n  }\n  return getUpdatePath(obj)\n};exports.getPath = getPath\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function getUpdatePath(data) {\n  const result = {}\n  dataToPath(data, result)\n  return result\n};exports.getUpdatePath = getUpdatePath\n\nfunction dataToPath(data, result) {\n  Object.keys(data).forEach(key => {\n    result[key] = true\n    const type = Object.prototype.toString.call(data[key])\n    if (type === OBJECTTYPE) {\n      _objToPath(data[key], key, result)\n    } else if (type === ARRAYTYPE) {\n      _arrayToPath(data[key], key, result)\n    }\n  })\n}\n\nfunction _objToPath(data, path, result) {\n  Object.keys(data).forEach(key => {\n    result[path + '.' + key] = true\n    delete result[path]\n    const type = Object.prototype.toString.call(data[key])\n    if (type === OBJECTTYPE) {\n      _objToPath(data[key], path + '.' + key, result)\n    } else if (type === ARRAYTYPE) {\n      _arrayToPath(data[key], path + '.' + key, result)\n    }\n  })\n}\n\nfunction _arrayToPath(data, path, result) {\n  data.forEach((item, index) => {\n    result[path + '[' + index + ']'] = true\n    delete result[path]\n    const type = Object.prototype.toString.call(item)\n    if (type === OBJECTTYPE) {\n      _objToPath(item, path + '[' + index + ']', result)\n    } else if (type === ARRAYTYPE) {\n      _arrayToPath(item, path + '[' + index + ']', result)\n    }\n  })\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function needUpdate(diffResult, updatePath) {\n  for (let keyA in diffResult) {\n    if (updatePath[keyA]) {\n      return true\n    }\n    for (let keyB in updatePath) {\n      if (includePath(keyA, keyB)) {\n        return true\n      }\n    }\n  }\n  return false\n};exports.needUpdate = needUpdate\n\nfunction includePath(pathA, pathB) {\n  if (pathA.indexOf(pathB) === 0) {\n    const next = pathA.substr(pathB.length, 1)\n    if (next === '[' || next === '.') {\n      return true\n    }\n  }\n  return false\n}\n\nif (!exports.__esModule) Object.defineProperty(exports, \"__esModule\", { value: true });function fixPath(path) {\n  let mpPath = ''\n  const arr = path.replace('#-', '').split('-')\n  arr.forEach((item, index) => {\n    if (index) {\n      if (isNaN(Number(item))) {\n        mpPath += '.' + item\n      } else {\n        mpPath += '[' + item + ']'\n      }\n    } else {\n      mpPath += item\n    }\n  })\n  return mpPath\n};exports.fixPath = fixPath\n"]}